\documentclass[onecolumn, draftclsnofoot,10pt, compsoc]{IEEEtran}

\usepackage{float}
\usepackage{graphicx}
\usepackage{url}
\usepackage{setspace}
\usepackage{geometry}
\usepackage{listings}
\usepackage{color}
\usepackage{etoolbox}
\usepackage{pdflscape}

\patchcmd{\thebibliography}{\section*{\refname}}{}{}{}

\geometry{textheight=9.5in, textwidth=7in}

% 1. Fill in these details
\def \CapstoneTeamName{			              			 PlanteR-GB}
\def \CapstoneTeamNumber{					           			 Group 64}
\def \GroupMemberOne{				           				Austin Hodgin}
\def \GroupMemberTwo{				           				Travis Hodgin}
\def \GroupMemberThree{			            Maximillian Schmidt}
\def\GroupMemberFour{		        	               Zach Lerew}
\def \CapstoneProjectName{	      	    Winter is Coming...}
\def \CapstoneSponsorCompany{		    Oregon State University}
\def \CapstoneSponsorPerson{		 			  				 Victor Hsu}

% 2. Uncomment the appropriate line below so that the document type works
\def \DocType{		%Problem Statement
				%Requirements Document
				%Technology Review
				%Design Document
				%Fall Progress Report
				Winter Midterm Progress Report
				}

\newcommand{\NameSigPair}[1]{\par
\makebox[2.75in][r]{#1} \hfil 	\makebox[3.25in]{\makebox[2.25in]{\hrulefill} \hfill		\makebox[.75in]{\hrulefill}}
\par\vspace{-12pt} \textit{\tiny\noindent
\makebox[2.75in]{} \hfil		\makebox[3.25in]{\makebox[2.25in][r]{Signature} \hfill	\makebox[.75in][r]{Date}}}}
% 3. If the document is not to be signed, uncomment the RENEWcommand below
\renewcommand{\NameSigPair}[1]{#1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\begin{titlepage}
    \pagenumbering{gobble}
    \begin{singlespace}
    	%\includegraphics[height=4cm]{coe_v_spot1}
        \hfill

        % 4. If you have a logo, use this includegraphics command to put it on the coversheet.
        \includegraphics[height=4cm]{logo.png}

        \par\vspace{.2in}
        \centering
        \scshape{
            \huge CS Capstone \DocType \par
            {\large\today}\par
            \vspace{.5in}
            \textbf{\Huge\CapstoneProjectName}\par

            %\vfill
						\vspace{1in}

            {\large Prepared for}\par
            \Huge \CapstoneSponsorCompany\par
            \vspace{5pt}
            {\Large\NameSigPair{\CapstoneSponsorPerson}\par}

						\vspace{1in}

            {\large Prepared by}\par
						{\huge \CapstoneTeamNumber}\par
            \CapstoneTeamName\par
            \vspace{5pt}

            {
							\Large
							\NameSigPair{\GroupMemberOne}\par
							\NameSigPair{\GroupMemberTwo}\par
							\NameSigPair{\GroupMemberThree}\par
							\NameSigPair{\GroupMemberFour}\par
            }

            \vspace{20pt}
        }
%\textbf{\textsuperscript{citation needed}}
				\newpage
        \begin{abstract}
				\noindent This document details what the team has accomplished for the second stage of the project.
				It covers the progress made on the programming portion of the project,
				as well as problems we faced and the solutions implemented.
				This document contains four sections written be each of the team's members.
				These sections explain the individual work accomplished by each of us.
        \end{abstract}
    \end{singlespace}
\end{titlepage}

\newpage

\pagenumbering{arabic}
\tableofcontents
% 7. uncomment this (if applicable). Consider adding a page break.
%\listoffigures
%\listoftables
\clearpage
\singlespace

\newpage


% Syntax highlighting
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{
  backgroundcolor=\color{white},   % choose the background color
  basicstyle=\footnotesize,        % size of fonts used for the code
  breaklines=true,                 % automatic line breaking only at whitespace
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  keywordstyle=\color{blue},       % keyword style
  stringstyle=\color{mymauve},     % string literal style
	frame = single,                  % code framing
}


%%%%%%%%%%%%%%%%%%%%%%% NOTES %%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	% Introduction
	\section{Purpose}
	The PlanteR-GB project is a configurable LED strip control system run by microcontrollers.
	The system intends to make growing plants easy and configurable by giving the user control over the state of every LED connected to the system.
	Through a local web interface, the system groups LEDs across multiple light strips into zones.
	Zones set the color, intensity, and power state of their LEDs based on a configurable schedule.
	Existing plant lighting systems offer little to no configuration options and cost between \$70 and \$100. \cite{expensive1} \cite{expensive2} \cite{expensive3}
	Our team is building an LED plant growing system from the ground up to offer configuration options and affordability.
	The trade off made for a lower price is more involvement during setup. Our team intends to release the project as open source software for the DIY community.
	Initially the project will require users to purchase the specific micro controllers used by the system, flash the control software, and wire the system together.
	Our stretch goals include purchasable kits which include all of the necessary parts and instructions to build the system for yourself, and possibly custom enclosures that are sold as pre-made working systems.

	\section{Goals}
	The PlanteR-GB lighting system will allow users to change individual LEDs to a specific color and intensity at any time throughout the day or week.
	LEDs on up to twenty light strips can be grouped into zones and controlled on a schedule with a local web interface.

	\section{Status}
	The project is now in an alpha state.

	\section{Austin Hodgin}
	\section{Travis Hodgin}
	\section{Max Schmidt}
	\section{Zach Lerew}
	For my portion of the project’s ALPHA, I wrote the API, Internal State, and started the Data Parser.
	The API is a RESTful http endpoint which spawns a series of child listeners and defines a set of routes which map to action functions.
	The library I chose to implement this is called Pistache, an element C++ REST framework.
	Each of these routes use a different http verb, depending on the type of CRUD operation the route implements.
	For example, adding a profile to the system uses a POST request because the request introduces new data.
	Adding an existing LED to an existing zone uses a PUT request because it links existing items.
	Viewing information uses the GET verb, and deleting it uses the DELETE verb.
	Each API route maps to an action, much like the ASP.NET framework.
	The action methods take JSON data as input and make changes to the internal state.
	For example, a call to http://localhost:9080/profiles/add with the JSON data
	\begin{lstlisting}
	{“name”:”Test Profile”, “description”: “Winter herbs”}
	\end{lstlisting}
	will create an internal state Profile object with a name and description set.
	The request will return the ID of the newly created object, or an error if the operation was not successful.
	Afterwards, a call to http://localhost:9080/profiles/1 will return the JSON data
	\begin{lstlisting}
	{“name”:”Test Profile”, “description”:”Winter herbs”, “id”:1, “zones”:[]}
	\end{lstlisting}
	When retrieving data, the API uses the Nlohmann JSON library to convert between objects and their text representations. The library has a useful feature that allows me to define from\_json and to\_json functions for each of the internal state objects. These methods are called automatically when implicitly converting the internal state objects into JSON.
	\begin{lstlisting}
	json j_out = *profile;
	\end{lstlisting}
	The conversion works in the opposite direction too, by calling
	\begin{lstlisting}
	json::parse(request.body())
	\end{lstlisting}
	and implicitly casting it to a Profile object. The JSON library also provides numerous methods for easy parsing of JSON objects and lists.
	The API is the entry point for the system as a whole, and is the primary method by which data is entered into the system.
	The command line interface as well as the web interface connect to the API by calling its routes and passing JSON data, so it is essential that the API is well documented and provides all necessary actions.

	After a request is processed by the API, the internal state takes over by providing a series of object methods which are called in order to add new data or link existing data together.
	The internal state is the in memory representation of the system and all of its settings.
	It has six types of objects. Two of the objects are virtual representations of the physical system, the LED and its associated Controller.
	Two of the objects represent unique permutations of a set of possible states. The first of those is the LEDState, which is a combination of red, green, blue, intensity, and power status.
	The second unique object is the Daily State which represents all led states which occur in a day.
	A single daily state can be used for multiple days of the week, allowing a single daily schedule object to be used every day of the week without creating more data.
	The daily state contains a dictionary of mappings between a time (in seconds after midnight) and pointers to LED states.
	The fourth object is the Zone, which contains a set of 7 daily states and a list of LEDs.
	The Zone has an algorithm in it which looks through the set of 7 daily states and finds a pointer to the current LED state which should be active based on the system's day and time.
	If an LED state cannot be found anywhere in the week, the zero LED state is returned, which represents an state of no color, no intensity, and no power.
	The final object is the Profile, which contains a name, description, and set of zones.
	Each profile represents an overall state of the system, a unique combination of a schedule and a set of LEDs.
	One possible user story would be a series of four profiles, one for each season.
	During different seasons the user may grow different vegetables depending on seed availability and preference. Changes made to the internal state exist only in memory, and are lost when the system resets, or in the case of our alpha, crashes.

	The data parser exists to save the data within the internal state into the file system and later retrieve it back into memory.
	The chosen library is sqlite\_orm by fnc12 on github.
	This library is likely the most flexible database Object Relational Mapping system available for C++ while still being quick to learn.
	This system allows you to build the database schema using objects by passing the results of a make\_table call to a make\_storage function.
	The make\_table function takes a series of make\_column calls which in turn take pointers to accessor and mutator functions for each of the objects in the system.
	Once the storage object is created on the file system and the schema defined in memory, the ORM provides a series of SQL like functions such as insert, update, replace, remove, and so on.
	These functions take an instance of an object such as a Zone, and automatically generate and call the appropriate SQL code.
	The ORM also provides lamba style functions which replicate SQL functions like JOIN, WHICH, and aggregate functions such as COUNT or SUM.
	In a similar manner as the JSON library, the sqlite\_orm library takes a heavy amount of setup for schema definition, after which subsequent operations are quick and painless.
	Once the data is stored on the file system, it can be loaded in the dataParser’s initialize function.
	The ORM library provides a series of select functions which allow a direct translation into standard C++ STL container containing objects.
	My favorite part of this ORM library is the insert functions which take an internal state object and returns the ID of the newly created object.
	This allows me to keep object IDs unique easily as well as pass them around in the API as objects are created, modified, and deleted.
	During the project so far, I have been responsible for a lot of the middle parts of the system, and as such have been responsible for making sure my team understands what data to give me, and what data they are getting from me.



	\section{Problems}
		\subsection{Problem name}
			Problem description
		\subsubsection{Solution}
				Problem solution
	\subsection{Libraries Not well documented}
      Problem description
  	\subsubsection{Solution}
	    Problem solution
	 	\subsection{Five Person Scheduling}
		 Seeing that the group consists of four members, and our client's schedule contains busy times similar to ours, scheduling times that worked for everyone
		 forced compromises in meeting times.
  	\subsubsection{Solution}
		  With no "perfect" times aligning in anyone's schedules, some group members had to cut time from work, other class work, or personal time to work on the project.
		  There was no "clean" solution to the scheduling issue.


	\section{Remaining work}
	Data parser
	CLI Multi zones, colors
	Web interface
	State composer multiple microcontrollers
	Large system tests


	\section{References}
			\begingroup
				\renewcommand{\addcontentsline}[3]{}% Remove functionality of \addcontentsline
				\renewcommand{\section}[2]{}% Remove functionality of \section
				%\cite[Sec 3.8]{sourceName}
				\bibliography{ref}
				\bibliographystyle{IEEEtran}
			\endgroup
\end{document}
